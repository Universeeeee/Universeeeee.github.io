---
title: 消息队列选型研究
cover: images/cover/mq.jpg
---

## 一、使用消息队列的目的

1. 解耦
2. 异步
3. 削峰

注：当然不光这些目的，消息队列的作用另开一篇详细记录吧。

## 二、消息队列的缺点

1. 系统可用性降低

   系统引入的外部依赖越多，越容易挂掉。万一 消息队列挂了可能会造成整套系统崩溃，需要保证消息队列的高可用。

2. 系统复杂度提高

   需要保证消息没有重复消费，需要处理消息丢失的情况，需要保证消息传递的顺序性。

3. 一致性问题

   A 系统处理完了直接返回成功了，都以为这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，这数据就不一致了。

## 三、主流消息队列对比

![mq1](https://Universeeeee.github.io/source/_posts/architecture-design/mq/mq1.jpg)

选择消息队列框架需要根据具体业务需求、技术栈、运维能力和场景特点来综合决策。以下是不同场景下的选型建议及关键注意事项：

---

## **四、核心选型维度**

#### **1. 消息模型与协议**

- **队列模型 vs 发布订阅模型**：
  - **RabbitMQ**：基于 AMQP 协议，支持灵活的路由规则（Direct/Fanout/Topic/Headers），适合复杂路由场景。
  - **Kafka/RocketMQ/Pulsar**：基于分区（Partition）的发布订阅模型，天然支持高吞吐和水平扩展。
  - **MQTT Broker（如 EMQX）**：适用于物联网场景，支持低带宽、高延迟网络。

#### **2. 性能需求**

- **高吞吐场景（日志、大数据流）**：
  - **Kafka**：单机吞吐可达百万级 QPS，适合日志采集、实时分析。
  - **Pulsar**：通过分层存储（Apache BookKeeper）支持更高吞吐和持久化。
- **低延迟场景（实时交易、即时通讯）**：
  - **RabbitMQ**：微秒级延迟，适合实时性要求高的业务。
  - **Redis Streams**：内存存储，延迟极低，但可靠性较弱。

#### **3. 消息可靠性**

- **金融级可靠性（不丢消息）**：
  - **Kafka**：通过 ISR 副本同步、ACK 机制（all）保证数据不丢失。
  - **RocketMQ**：支持同步刷盘（SYNC_FLUSH）和主从同步复制。
- **注意避坑**：RabbitMQ 默认异步刷盘，需手动开启持久化（durable queues）和 Publisher Confirm。

#### **4. 顺序消息**

- **严格顺序性（如订单状态变更）**：
  - **Kafka**：同一分区内消息有序，但分区数影响并发。
  - **RocketMQ**：支持全局顺序消息（单分区）和分区顺序消息。
  - **避坑**：消费者必须单线程消费，否则顺序会乱。

#### **5. 事务消息**

- **分布式事务（如订单支付）**：
  - **RocketMQ**：原生支持事务消息（两阶段提交）。
  - **Kafka**：通过 Transactional API 实现，但配置复杂。
  - **RabbitMQ**：无原生事务支持，需通过 Confirm 机制+业务补偿。

#### **6. 扩展性与运维**

- **大规模集群**：
  - **Kafka/Pulsar**：天然分布式设计，支持水平扩展。
  - **RabbitMQ**：集群需配合镜像队列，扩展性较弱。
- **云原生托管**：
  - **AWS Kinesis/Azure Event Hubs/阿里云 RocketMQ**：免运维，适合中小团队。

#### **7. 生态与语言支持**

- **多语言客户端**：
  - **RabbitMQ**：支持几乎所有主流语言（Java/Python/Go 等）。
  - **Kafka**：社区客户端丰富，但部分语言（如 C#）生态较弱。
- **流处理集成**：
  - **Kafka**：与 Flink/Spark Streaming 无缝集成。
  - **Pulsar**：内置轻量级计算框架 Pulsar Functions。

---

### **典型场景推荐**

#### **1. 大数据日志采集**

- **推荐框架**：Kafka
- **理由**：高吞吐、持久化存储、与 Hadoop/Spark 生态无缝集成。
- **避坑**：合理设置分区数（避免过多导致 ZooKeeper 压力）和保留策略（避免磁盘爆满）。

#### **2. 电商交易系统**

- **推荐框架**：RocketMQ
- **理由**：支持事务消息、顺序消息、堆积能力强，适合秒杀、订单状态流转。
- **避坑**：避免消费者堆积导致 Broker 内存溢出（需监控消费延迟）。

#### **3. IoT 设备通信**

- **推荐框架**：EMQX（MQTT 协议）
- **理由**：低功耗、支持海量连接、MQTT 协议适配设备端。
- **避坑**：设备端网络不稳定时需处理遗嘱消息（Last Will）和重连机制。

#### **4. 微服务异步解耦**

- **推荐框架**：RabbitMQ
- **理由**：灵活的路由、低延迟、易于集成 Spring Cloud 等框架。
- **避坑**：队列未消费消息积压时，需设置 TTL 或死信队列防止内存泄漏。

#### **5. 金融级高可靠场景**

- **推荐框架**：Kafka（需配置 ACK=all + ISR 最小副本数）
- **理由**：数据持久化和副本机制成熟。
- **避坑**：避免使用异步 Producer（可能丢消息），禁用 unclean leader 选举。

#### **6. 云原生 Serverless 场景**

- **推荐框架**：AWS SQS/Azure Service Bus
- **理由**：完全托管，按需付费，无需维护基础设施。
- **避坑**：注意消息可见性超时（Visibility Timeout）配置，避免重复消费。

---

## **五、避坑指南**

1. **消息丢失问题**：
   - **Producer 端**：开启 ACK 确认（如 Kafka 的 acks=all，RabbitMQ 的 Publisher Confirm）。
   - **Broker 端**：启用持久化（如 Kafka 的 replication.factor≥3）。
   - **Consumer 端**：手动提交 Offset（避免自动提交导致消息丢失）。
2. **消息重复消费**：
   - **幂等性设计**：业务逻辑需支持幂等（如唯一 ID+去重表）。
   - **Kafka**：启用 enable.idempotence=true 防止 Producer 重复发送。
3. **资源规划不足**：
   - **磁盘**：Kafka/RocketMQ 需预留大量磁盘空间（日志保留策略）。
   - **网络**：跨机房部署时避免网络分区（如 RabbitMQ 优先用内网集群）。
4. **版本兼容性**：
   - **Kafka**：注意客户端与 Broker 版本兼容性（如 0.11+支持事务消息）。
   - **RabbitMQ**：Erlang 版本与 RabbitMQ 版本严格绑定，升级需谨慎。
5. **监控告警缺失**：
   - **必监控指标**：堆积消息数、Consumer Lag、Broker CPU/磁盘 IO。
   - **工具**：Prometheus + Grafana（Kafka Exporter）、RabbitMQ Management UI。

---

## **六、总结**

- **中小团队/快速迭代**：优先考虑云托管服务（如 AWS SQS/Aliyun RocketMQ）。
- **高吞吐大数据场景**：Kafka/Pulsar。
- **复杂路由与实时性**：RabbitMQ。
- **金融/强一致性场景**：RocketMQ。
- **物联网低功耗场景**：EMQX（MQTT）。

最终选型还是要结合团队技术栈、运维能力和长期维护成本综合评估，必要时可通过 POC 测试压测关键指标（如吞吐、延迟、故障恢复时间）。

## 七、补充

### **（一）关于 ActiveMQ **

1. **吞吐量验证**：
   - ActiveMQ 的 **经典版本（ActiveMQ Classic）** 吞吐量确实较弱（单机万级 QPS），但其衍生版本 **ActiveMQ Artemis**（2015 年发布）采用高性能架构（Netty + Journal 存储），吞吐量提升显著（十万级 QPS），已在部分企业级场景应用（如金融行业内部系统）。
   - **避坑点**：Artemis 与 Classic 兼容性差，需明确版本差异。
2. **社区活跃度**：
   - ActiveMQ 的 GitHub 仓库（Apache 官方）**近一年仍有更新**，但频率低于 Kafka/RocketMQ。社区讨论主要集中在邮件列表，国内技术圈热度较低。
   - **结论**：ActiveMQ 仍可用于传统企业内网场景（如 ERP 系统异步化），但新项目不建议优先选择。

---

### **（二）关于 RabbitMQ **

1.  的运维门槛\*\*：

- RabbitMQ 的 **管理界面（Management Plugin）** 和 **CLI 工具** 足够完善，无需深入掌握 Erlang 即可完成日常运维（如集群搭建、监控、队列管理）。
- **核心痛点**：Erlang 的故障排查和定制化开发（如修改协议）需要专业人才，但 90% 的中小企业不会涉及此场景。

2. **可控性与社区**：
   - **云托管服务**：AWS、阿里云等提供 RabbitMQ 托管版，彻底免运维。
   - **社区生态**：RabbitMQ 的插件市场（如延迟消息插件、Prometheus 监控插件）丰富，Spring 生态集成成熟，适合快速落地。
   - **结论**：中小团队完全可控，无需过度担忧技术栈差异。

---

### **（三）关于 RocketMQ **

1. **社区现状**：
   - RocketMQ 已进入 **Apache 顶级项目**（TLP），核心团队由阿里、腾讯、携程等企业维护，2023 年仍保持每月迭代。
   - **GitHub 数据**（截至 2023 年）：
     - **Stars**: ~20k（低于 Kafka 的 ~25k，高于 RabbitMQ 的 ~11k）
     - **Contributors**: ~500（活跃贡献者约 30 人，低于 Kafka 的 ~1500，但高于 Artemis）
   - **结论**：社区健康度良好，国内企业主导，国际影响力逐步提升。
2. **适用场景**：
   - **优势**：事务消息、顺序消息、堆积能力（支持亿级消息堆积）适合复杂业务（如电商、物流）。
   - **痛点**：
     - 部署复杂度高于 RabbitMQ（需独立部署 NameServer、Broker）。
     - 官方文档国际化程度不足，部分高级功能（如 ACL 鉴权）需参考源码或社区案例。
   - **结论**：**非仅限大公司**，中小团队若需事务消息等高阶功能亦可采用，但需投入学习成本。

---

### **（四）关于 Kafka **

1. **场景扩展性**：
   - **核心场景**：日志采集、流处理（Flink/Spark/Kafka Streams）仍是 Kafka 的主战场，但其在 **业务消息领域**（如订单处理）的应用也在增长（需配合事务 API 和幂等 Producer）。
   - **缺点**：
     - 单消费者组内分区数限制并发度，不适合需要大量并行消费者的场景。
     - 原生不支持延迟消息，需自建外部服务（如通过 Streams API 实现）。
2. **社区与生态**：
   - **Confluent（Kafka 商业公司）** 提供企业级支持（如跨集群同步、高级鉴权），降低运维风险。
   - **云服务**：MSK（AWS）、Confluent Cloud 等托管服务大幅降低使用门槛。

---

### **（五）其他框架**

#### **1、其他 ulsar**

- **优势**：
  - 计算存储分离架构（基于 BookKeeper），支持无缝扩缩容和分层存储（冷热数据分离）。
  - 原生支持多租户、轻量级函数计算（Pulsar Functions）。
- **适用场景**：
  - 云原生多租户平台（如 SaaS 系统）、需要长期存储的消息流水（如审计日志）。

#### **2. Redis Streams**

- **优势**：内存级延迟（微秒级），适合实时排行榜、秒杀计数器等场景。
- **缺点**：数据持久化可靠性弱，通常需配合其他 MQ 使用。

#### **3. 云厂商队列服务**

- **AWS SQS/Azure Service Bus/阿里云 MNS**：
  - 完全托管、按量付费，适合中小团队快速验证业务。
  - 缺点：功能较开源框架少（如无复杂路由），长期成本可能较高。

---

## **八、综合选型建议**

| **公司规模/场景**       | **推荐框架**                        | **核心理由**                                   |
| :---------------------- | :---------------------------------- | :--------------------------------------------- |
| **中小团队/微服务解耦** | RabbitMQ / 云托管队列（如 AWS SQS） | 低运维成本、快速集成、社区支持完善。           |
| **电商/物流/交易系统**  | RocketMQ                            | 事务消息、顺序消息、堆积能力强，国内生态成熟。 |
| **大数据/日志采集**     | Kafka                               | 高吞吐、流处理生态完善，社区绝对主流。         |
| **物联网（IoT）**       | EMQX（MQTT）                        | 海量设备连接、低功耗协议支持。                 |
| **云原生/多租户平台**   | Apache Pulsar                       | 计算存储分离、弹性扩展、内置函数计算。         |
| **金融级高可靠**        | Kafka（ACK=all） / RocketMQ（SYNC） | 数据持久化、副本同步机制严格。                 |

---

## **九、补充总结**

1. **ActiveMQ**：不推荐新项目使用，但 Artemis 版本仍有特定场景价值。
2. **RabbitMQ**：Erlang 不构成主要运维障碍，中小团队可控性足够。
3. **RocketMQ**：社区风险低，适用场景不仅限于大公司，但需权衡文档和部署成本。
4. **Kafka**：地位正确，但需注意其在业务消息场景的局限性。
5. **遗漏点**：未提及 Pulsar、云托管服务、Redis Streams 等新兴方案。

---

## **十、建议**

- **技术选型公式**：
  **业务需求（功能+性能） > 团队技术栈 > 运维成本 > 社区生态 > 厂商绑定风险**
- **推荐动作**：
  - 列出业务的核心需求（如是否需要事务、顺序消息）。
  - 对候选框架进行 POC 测试（吞吐量、延迟、故障恢复）。
  - 优先考虑云托管服务（减少运维负担），其次选择开源框架+商业化支持（如 Confluent for Kafka）。
